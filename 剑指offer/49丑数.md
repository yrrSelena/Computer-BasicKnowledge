## 题目
[面试题49. 丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)

我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

示例:

输入: n = 10

输出: 12

解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。

说明:  

1 是丑数。

n 不超过1690。

## 方法
### 思路（动态规划）
- 采用动态规划的方法，将前面求得的丑数记录下来，后面的丑数就是前面的丑数\*2,\*3,\*5
- 采用3个指针p2,p3,p5，其中p2指向的数字下次永远\*2，p3指向的数字下次永远\*3，p5指向的数字下次永远\*5
- 2\*p2 3\*p3 5\*p5选取最小的一个数字，作为第k个丑数
- 如果第K个丑数==2\*p2，也就是说前面0-p2个丑数\*2不可能产生比第K个丑数更大的丑数了，所以p2++。p3,p5同理
- 返回第n个丑数
### 复杂度分析
- 时间复杂度O(N)：动态规划需要遍历计算dp数组
- 空间复杂度O(N)：需要长度为N的dp数组

### 代码
```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> dp(n);
        dp[0]=1;
        int p2=0,p3=0,p5=0;
        for(int i =1;i<n;i++){
            dp[i]=min(min(2*dp[p2],3*dp[p3]),5*dp[p5]);
            if(dp[i]==2*dp[p2]){
                p2++;
            }
            if(dp[i]==3*dp[p3]){
                p3++;
            }
            if(dp[i]==5*dp[p5]){
                p5++;
            }
        }
        return dp[n-1];
    }
};
```

### 测评
执行用时 :16 ms, 在所有 C++ 提交中击败了43.04%的用户

内存消耗 :7.5 MB, 在所有 C++ 提交中击败了100.00%的用户
