[TOC]


## C++

#### C和C++的特点和区别

- C：面向过程的结构化语言
- C++
  - 在C语言的基础上进行了扩充和完善，使C++兼容了C语言的面向过程的特点，又成为了一种面向对象的程序设计语言
  - 具有抽象、继承、多态的特点

#### 面向对象三大特征

- 封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或对象操作，而对不可信的类或对象进行隐藏。关键字：public, protected, private(默认)
  - public：可以被任意实体访问
  - protected：只允许被子类及本类的成员函数访问
  - private：只允许被本类的成员函数、友元类、友元函数访问
- 继承：让某个类型的对象获得另一个类型对象的属性。基类（父类）->派生类（子类）
  - 实现继承：直接使用基类的属性和方法而无需额外编码的能力
  - 接口继承：仅使用属性和方法的名称，但是子类必须提供实现的能力
- 多态：多种形态，一个类实例的相同方法在不同情形中有不同的表现形式，以封装和继承为基础
  - 重载多态：函数重载、运算符重载
  - 参数多态性：类模板、函数模板
  - 子类型多态：虚函数
  - 强制多态：基本类型转换、自定义类型转换

#### 智能指针

#### 虚函数

#### 内存分配

#### const

1. 修饰变量，说明该变量不可以被改变；
2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；
3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；
4. 修饰成员函数，说明该成员函数内不能修改成员变量。

#### 友元类和友元函数

- 能够访问私有成员
- 破坏封装性
- 友元关系不能传递
- 友元关系具有单向性
- 友元声明的形式及数量不受限制





#### new和malloc的区别，失败后怎么处理

> https://www.cnblogs.com/ywliao/articles/8116622.html

|                  | malloc                                                   | new                                                          |
| ---------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| 属性             | 是库函数，需要添加头文件                                 | 是操作运算符，可重载                                         |
| 内存分配大小     | 按指定的大小分配，需要显式指定字节数                     | 按数据类型分配，编译器根据类型计算得到，不需要显式指定内存块大小 |
| 内存分配位置     | 堆                                                       | 自由存储区（抽象概念，可以是堆/静态存储区/...看operator new在哪里为对象分配内存） |
| 申请空间时       | 不调用构造函数                                           | 调用构造函数                                                 |
| 成功返回值       | void* （一般需要进行类型转换）                           | 指定对象的指针（类型安全性）                                 |
| 销毁             | free（不调用析构函数）                                   | delete（调用对象的析构函数）                                 |
| 已分配内存的扩充 | 可以用realloc扩容                                        | 无法直接处理                                                 |
| 内存分配失败时   | 内存不够时，返回NULL（因此malloc后最好判断其是否为NULL） | 抛出bad_malloc异常                                           |
| 申请数组时       | 只能用`sizeof(int)*n`                                    | new[]一次分配所有内存，多次调用构造函数                      |
| 销毁数组         |                                                          | delete[]，多次调用析构函数，销毁每个对象                     |

```c++
int * a = (int *)malloc(sizeof(int));//分配单个变量
int * arr = (int *)malloc(sizeof(int) * n);//分配一个数组
free(a);//释放变量a
free(arr);//释放数组

A * ptr = new A;//分配单个对象
A * ptr_arr = new A[10];//分配10个A对象
delete ptr;
delete [] ptr_arr;
```



#### C++内存管理



- 了解的数据结构，对hash_map是否了解
- 排序算法，什么是稳定性，快排是稳定排序嘛
- 内存模型
- 内存泄漏
- 什么是野指针
- 重载和覆盖
- STL常用的几种
- vector



## 数据库

### 数据库基础

#### 什么是SQL？

SQL：结构化查询语言，功能包括数据查询、数据操作、数据定义、数据控制

用于数据存取、查询、更新和管理关系数据库系统。

- 数据查询：通过select语句得到所需信息
- 数据操作：包括插入(insert)、修改(update)、删除(delete)
- 数据定义：对数据库用户、基本表、视图、索引进行定义(create)与撤销(drop)
- 数据控制：对数据库进行统一的控制管理，保证数据在多用户共享的情况下能够安全(grant为用户授予系统权限、revoke收回系统权限)

```sql
select * from Employee group by DepartmentId having count()>1
```

#### 数据库三大范式

- 第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项，属性不能再分解

- 第二范式（2NF）：在第一范式的基础上，**不存在部分依赖**，非主键列完全依赖于主键，而不能是依赖于主键的一部分（主要针对联合主键）
- 第三范式（3NF）：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。非主属性不能相互依赖，**不能存在传递关系**（不能存在a->b->c）

比如Student表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）

这样一个表结构，就存在上述关系。 学号--> 所在院校 --> (院校地址，院校电话)

这样的表结构，我们应该拆成两个表：（学号，姓名，年龄，性别，所在院校）--（所在院校，院校地址，院校电话）

#### 数据类型

1. 整数类型：bit, bool, tinyint,smallint, mediumint,int,bigint...
   - 任何整数类型都可加上unsigned属性，表示非负整数
   - 可以被指定长度 int(11)
2. 浮点数类型：float, double, decimal
   - float和double有取值范围，计算效率高于decimal
   - decimal可理解为用字符串处理
3. 字符串类型：char, varchar, blob, text,...
   - char：定长，适合存储很短的字符串，或者所有值都接近同一长度
   - varchar：可变长，比定长类型更省空间，使用额外1或2个字节存储字符串长度
4. 日期类型：date, datetime, timestamp, time,..
   - 尽量是同timestamp，空间效率高于datetime
   - 如果要存储微秒。可以使用bigint存储
5. 其它类型



#### MySQL架构

mysql可以根据业务需求和实际需要选择合适的存储引擎

- **连接层**：最上层是一些客户端和连接服务。**主要完成一些类似于连接处理、授权认证、及相关的安全方案**。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。
- **服务层**：第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等
- **引擎层**：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取
- **存储层**：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互

##### mysql的查询流程/ 一条sql语句在mysql中如何执行

客户端请求 ---> 连接器（验证用户身份，给予权限） ---> 查询缓存（存在缓存则直接返回，不存在则执行后续操作） ---> 分析器（对SQL进行词法分析和语法分析操作） ---> 优化器（主要对执行的sql优化选择最优的执行方案方法） ---> 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口） ---> 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）

![preview](E:\7_work\算法准备\面试准备.assets\v2-0195fa9bab098b73c4f07bfb5e41e58e_r.jpg)

#### 存储引擎

存储引擎是MySQL的组件，用于处理不同表类型的SQL操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。

**一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求**，使用合适的存储引擎，将会提高整个数据库的性能 。

InnoDB 现在是 MySQL 默认的存储引擎，支持**事务、行级锁定和外键**

##### MyISAM vs InnoDB

|                                    | MyISAM                                                       | InnoDB                                                       |
| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 事务                               | 不支持                                                       | 支持                                                         |
| 崩溃后安全恢复                     | 不能                                                         | 能                                                           |
| 外键                               | 不支持                                                       | 支持                                                         |
| 最小锁粒度                         | 表锁（table-level locking，一个更新语句会锁住整个表，导致其它查询和更新都被阻塞，不适合高并发操作） | 行锁（row-level locking，操作时只锁某一行，不对其他行产生影响，适合高并发操作） |
| MVCC                               | 不支持                                                       | 支持                                                         |
| 索引                               | 非聚簇索引                                                   | 聚簇索引                                                     |
| 表主键                             | 允许没有任何索引和主键的表存在                               | 若没有设定主键或非空唯一索引，就会自动生成一个6字节的主键（用户不可见） |
| 存储结构                           | 三个文件：表定义文件(.frm)、数据文件(.MYD)、索引文件(.MYI)   | 所有表都存在一个数据文件中（表的大小之受限于操作系统文件的大小，一般为2GB） |
| `select count(*) from table; `速度 | 快（用一个变量保存了整个表的行数，执行该语句只需要读出该变量即可） | 不保存表的具体行数（与MVCC有关），执行该语句时需要全表扫描   |
| 应用场景                           | 管理非事务表，提供高速存储和检索及全文搜索能力。在应用中需执行大量select操作，或表比较小，且可以忍受修复操作 | 用于事务处理，在应用中执行大量insert和update操作             |

> 一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？

如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID 记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；

如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。

#### InnoDB引擎的4大特性





### 索引

- 定义：帮助MySQL高效获取数据的**数据结构**
- 目的：提高查询效率（类比字典）
- 存储位置：一般以索引文件的形式存储在**磁盘**上（索引本身很大，不可能全部存储在内存中）
- 基本语法

```mysql
# 创建索引
CREATE [UNIQUE] INDEX indexName ON tableName(columnName(length));
ALTER table tableName ADD [UNIQUE] INDEX indexName(columnName);
# 删除索引
DROP INDEX [indexName] ON mytable;
```

#### 索引的优缺点

- 优势
  - 提高检索效率，降低数据库IO成本
  - 降低数据排序成本，降低CPU消耗
  - 加速表和表之间的连接，特别使在实现数据的参考完整性方面具有重要意义
  - 使用分组和排序子句进行数据检索时，可减少查询中分组和排序的时间
- 劣势：
  - 空间：需要占用内存，如果建立聚集索引，则需要更大的空间；
  - 时间：索引的创建和维护都需要时间，当对表中数据进行增加、删除、修改时，索引也要动态维护，降低更新表的速度

#### 添加索引的原则

- 在查询中很少使用或者参考的列不应该创建索引
- 只有很少数据值的列不应该创建索引（如性别）
- 定义为text、image、bit数据类型的列不应该创建索引，这些列的数据量要么相当大，要么取值很少

#### 索引类型

- 主键索引
- 唯一索引
- 普通索引
- 全文索引

#### 数据库索引的原理，为什么要用 B+树，为什么不用二叉树？

- B+树只有叶子节点才存储数据（所有数据记录节点都按照简直大小顺序存放在同一层的叶子节点上），非叶节点只存储键值信息。这样可以加大每个节点存储键值的数量，降低B+树的高度

所以查找相同数据量的情况下，B树的高度更高，IO更频繁。

数据库索引存储在磁盘上，当数据量大时，不能把整个索引加载到内存中，只能逐个加载每个磁盘页（对应索引树的节点）。

MySQL底层对B+树进行进一步优化：在叶子节点中是双向链表，且在链表的头节点和尾节点也是循环指向的（可以加快相邻数据的检索效率）

#### 聚集索引 vs 非聚集索引

主索引：主键索引，键值不能重复； 辅助索引：非主键索引，普通索引，键值可重复

- 聚簇索引（将数据存储与索引放在一起）
  - InnoDB的**数据文件本身就是主键索引文件**（按B+树组织的索引结构文件），一个表只能有一个聚簇索引
  - 聚簇索引文件放在主键索引的叶子节点上，因此InnoDB**必须有主键**（推荐整型自增主键），通过主键索引效率很高。
  - 存储内容：InnoDB引擎索引结构的**叶节点存放的就是实际的数据记录**（主索引叶节点存储的是表中所有的数据记录，辅助索引叶节点存储的是主键值<保证数据一致性、节省存储空间>）。
  - 数据查找流程：不管是主键索引还是辅助索引，都需先查找索引节点，才能拿到相应的数据。辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不宜过大，否则其它索引也会很大。
- 非聚集索引（将数据存储与索引分开）
  - 索引文件和数据文件分离
  - 存储内容：MyISAM引擎索引的叶节点存放的是**数据记录的地址**（而不是实际数据记录）。主键索引和辅助索引相互独立。
  - 通过索引查找数据流程：从索引文件中查找到索引节点->从中拿到数据的文件指针->到数据文件中通过文件指针定位具体数据



InnoDB引擎中的索引策略，了解过吗？
创建索引的方式有哪些？
聚簇索引/非聚簇索引，mysql索引底层实现，为什么不用B-tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？

说说你对 MySQL 索引的理解？

### 事务

#### 基础

定义：操作数据库的最小工作单元，是逻辑上的一组操作，要么都执行，要么都不执行。

mysql开启事务：

```mysql
set session autocommit = on/off; #设定事务是否自动开启
#若为off，需要手动开启事务：
begin/start transaction #手动开启事务
commit/rollback  #提交事务/回滚事务
show variables like 'autocommit'; #查看事务开启的状态
```

转账举例：（从userID=3用户转给userID=1用户 1000块钱）

```mysql
begin/start transaction; #开启事务
update user_account set balance = balance -1000 where userID = 3;
update user_account set balance = balance + 1000 where userID = 1;
commit;  #提交
```



#### 事务的四大特性

1. 原⼦性（**Atomicity**）： 事务是最小的执行单位，不允许分割。事务的原⼦性确保动作要么全部完成，要么完全不起作⽤；

2. ⼀致性（**Consistency**）： 执行事务前后，数据保持⼀致，多个事务对同⼀个数据读取的结果是相同的；

3. 隔离性（**Isolation**）： 并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据库是独⽴的；

4. 持久性（**Durability**）： ⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。

#### 事务并发带来的问题

多个事务并发运行经常会操作相同的数据来完成各自的任务（多个任务对同一数据进行操作）

- 脏读：当事务T1正在访问数据且对数据进行了修改，但这种修改还没有提交到数据库，此时事务T2也访问并使用了这个数据。但是这个数据是还没有提交的数据，因此事务T2读到的数据是“脏数据”
- 丢失修改：在事务T1读取一个数据时，事务T2也访问并修改了该数据，那么在事务T1中的修改结果就会丢失。
- 不可重复读：事务T1多次读同一个数据，在T1还未结束时，事务T2访问并**修改**了该数据。那么事务T1两次读到的数据会不同。<强调修改>
- 幻读：事务T1读取了几行数据，此时事务T2**插入/删除**了一些数据。在随后的查询中，T1会发现多/少了一些原本不存在的记录，好像发生了幻觉。<强调增加/删除>

#### 事务并发问题的解决方法

- 丢失修改时
- 脏读、不可重复读、幻读，都是数据库读一致性问题，需由数据库提供一定的事务隔离机制来解决
  1. **加锁**：在读取数据前，对其加锁，阻止其他事务对数据进行修改
  2. **多版本并发控制**（MVCC, multi-version concurrency control）：不用加任何锁，通过一定机制生成一个数据请求时间点的**一致性数据快照**，并用这个快照提供一定级别（语句级/事务级）的一致性读取。（从用户的角度看来，好像是数据库可以提供同一个数据的多个版本）MVCC只在read committed和repeatable read两个隔离级别下工作，可以使用乐观锁和悲观锁实现

#### 事务的隔离级别

|      | 隔离级别   | 简介                                                         | 脏读 | 不可重复读 | 幻读 |
| ---- | ---------- | ------------------------------------------------------------ | ---- | ---------- | ---- |
| 1    | 读取未提交 | 允许读取尚未提交的数据变更                                   | √    | √          | √    |
| 2    | 读取已提交 | 允许读取并发事务已经提交的数据                               | ×    | √          | √    |
| 3    | 可重复读   | 对同一字段多次读取的结果都是一致的，除非数据被本身事务修改   | ×    | ×          | √    |
| 4    | 可串行化   | 最高隔离级别，完全服从ACID的隔离级别。所有事物依次逐个执行，事物之间完全不可能产生干扰 | ×    | ×          | ×    |

- 隔离级别越低，事务请求的锁越少
- mysql InnoDB默认支持的隔离级别为**可重复读**（repeatable-read），但由于采用的是next-key lock锁算法，可以避免幻读，实际已达到可串行化的隔离级别，可通过`select @@ tx_isolation;`命令来查看。
- InnoDB在分布式事务的情况下会用到serializable（可串行化）级别

- 事务隔离级别越高，数据访问的并发性越差

### 锁

#### 数据库的乐观锁和悲观锁

数据库管理系统（DBMS）中的并发控制任务是确保在多个事务同时存取数据库张同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。

- 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制
- 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候，把事务锁起来，通过version方式进行锁定。实现方式：一般使用版本号机制或CAS算法实现





## 操作系统

#### 进程 vs 线程

1. 进程是操作系统资源分配的最小单位，线程是CPU任务调度的最小单位。一个进程可以包含多个线程，所以进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。
2. 不同进程间数据很难共享，同一进程下不同线程间数据很易共享。
3. 每个进程都有独立的代码和数据空间，进程要比线程消耗更多的计算机资源。线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。
4. 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉。
5. 系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。
6. 线程可以直接与进程内的其它线程通信，进程间通过IPC（Inter-Process communication，进程间通信）通信

#### 进程通信方式有哪些？用过哪个？

>  [进程间的五种通信方式介绍](https://www.cnblogs.com/zgq0/p/8780893.html)
>
>  [进程间通信及使用场景](https://www.jianshu.com/p/4989c35c9475)

1.无名管道(pipe)，2.命名管道（FIFO），3.消息队列(msg)，4.共享内存(shm)，5.信号量(sem)，6.信号(signal)，7.socket

1. 无名管道：

   - 半双工<单向通信>，即数据只能在一个方向上流动，具有固定的读端和写端
   - 只能用于具有亲缘关系的进程之间的通信（父子进程或兄弟进程之间）
   - 可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于**内存**中，缓冲区有限。
2. 命名管道（FIFO是一种**文件**类型）

   - 可以在任意关系的进程间交换数据，与无名管道不同
   - FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。
   - FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。
   - 可以扩展成“客户进程—服务器进程”通信的实例，FIFO用作**汇聚点**，在客户进程和服务器进程二者之间传递数据。`write_fifo`的作用类似于客户端，可以打开多个客户端向一个服务器发送请求信息，`read_fifo`类似于服务器，它实时监控着FIFO的读端，当有数据时，读出并进行处理。前提：每一个客户端必须预先知道服务器提供的FIFO接口
3. 消息队列：

   - 消息队列，是**消息的链接表**，存放在**内核**中（只有在内核重启或显式删除一个消息队列时才会被真正删除）。一个消息队列由一个标识符（即队列ID）来标识。
   - 将数据分成了一个个独立的数据单位，每个数据单位为一个消息体。每个消息体都是固定大小的存储块，在字节流上不连续（vs管道<字节流上连续>）
   - 可以实现任意进程间的通信，通过系统调用函数来实现消息发送和接收之间的同步
   - 面向记录，其中的消息具有特定的格式以及特定的优先级。
   - 独立于发送和接受进程。进程终止时，消息队列及其内容不会被删除
   - 可以实现消息的随机查询，消息不一定要以先进先出的次序读取，可以按消息的类型读取
   - 消息结构体被发送的时候，**只是发送了消息结构体中成员的值**，如果结构体成员是指针，并不会将指针所指向的空间的值发送，而只是发送了指针变量所保存的地址值。数组作为消息体结构体成员是可以的。因为整个数组空间都在消息体结构体中
   - 缺：信息的复制需要额外消耗CPU时间，不适合信息量大或操作频繁的场合
4. 信号量：

   - 信号量是一个**计数器**，信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。
   - 用于进程间同步，若要在进程间传递数据，需要结合共享内存
   - 信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作
   - 每次对信号量的PV操作不仅限于对信号量值+1/-1，也可以加减任意正整数
   - 支持信号量组
5. 共享内存：

   - 共享内存指两个或多个进程共享一个给定的存储区，一般配合信号量使用。
   - 优：最快的一种IPC，进程直接对内存进行存取，无需复制
   - 多个进程可以同时操作，需要用信号量同步对共享内存的访问
   - 系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。通过让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。
   - 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，因此只能同一个计算机系统中的进程进行共享，难以进行网络通信
6. 信号：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生
7. socket
   - TCP/IP的抽象接口，可用于**不同计算机间**的进程通信
   - 传输数据为字节级，传输数据可自定义，数据量小、效率高
   - 可以加密，数据安全性强
   - server端：[1.socket]申请一个socket->[2.bind]将socket登记到固定位置->[3.listen]等待client连接->[4.accept]接受用户连接申请->[5.read/write]进行数据交换->[6.close]关闭连接
   - client端：[1.socket]申请一个socket->[2.connect]与server连接->[3.read/write]进行数据交换->[4.close]关闭连接

- 微信APP与其服务器通信，采用socket套接字进行通信。

  - 应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务

  |            | 优缺点                                                       |
  | ---------- | ------------------------------------------------------------ |
  | 管道       | 速度慢，容量有限，单向通信，只有父子进程能通讯               |
  | FIFO       | 任何进程间都能通讯，但速度慢                                 |
  | 消息队列   | 容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题（可实现多对对，需在内存中实现） |
  | 信号量     | 不能传递复杂消息，只能用来同步                               |
  | 共享内存区 | 能够很容易控制容量，速度快，但要保持同步                     |
  | socket     | 能够实现网络中进程间通信                                     |

#### 线程通信方式

- 临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；
- 互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
- 信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。
- 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

## 计算机网络

#### OSI七层和TCP/IP四层的区别，每层用到哪些协议

> [OSI七层协议模型、TCP/IP四层模型和五层协议](https://my.oschina.net/u/4398028/blog/3574288/print)

![img](https://oscimg.oschina.net/oscnet/4f1d9d3c53e7cd77149906c9ec5d292a905.png)

| OSI 7层    |                                                              | 单位                             | 协议                                                         | 工作设备                                           |
| ---------- | ------------------------------------------------------------ | -------------------------------- | ------------------------------------------------------------ | -------------------------------------------------- |
| 应用层     | 网络服务与最终用户的一个接口                                 | 报文                             | 建立在TCP协议之上：HTTP、FTP、TELNET、SMTP、POP3 、IMAP、SSL；建立在UDP协议之上：SNMP、DNS、DHCP、TFTP、RTP |                                                    |
| 表示层     | 数据的表示、安全、压缩                                       |                                  |                                                              |                                                    |
| 会话层     | 建立、管理、终止会话                                         |                                  |                                                              |                                                    |
| 传输层     | 建立了主机端到端的链接，定义传输数据的协议端口号，以及流控和差错校验 | 报文段（TCP）、用户数据报（UDP） | TCP UDP                                                      |                                                    |
| 网络层     | 进行逻辑地址寻址，实现不同网络之间的路径选择（选择合适的网间路由和交换结点，确保数据及时传送） | IP数据报                         | ICMP（网际控制消息协议） IGMP IP（网际协议 IPV4 IPV6） ARP（地址解析协议） RARP | 路由器                                             |
| 数据链路层 | 建立逻辑连接、进行硬件地址寻址、差错校验 等功能              | 帧                               | PPP(点对点协议) 由底层网络定义协议                           | 网桥、交换机                                       |
| 物理层     | 实现相邻计算机节点之间比特流的透明传输，尽可能屏蔽掉具体传输介质和物理设备的差异 | 比特                             | 由底层网络定义协议                                           | 集线器、中继器、调制解调器、网线、双绞线、同轴电缆 |



#### 三次握手（建立连接）

> https://blog.csdn.net/qzcsu/article/details/72861891

刚开始客户端处于closed状态，服务端处于listen状态

1. 第一次握手：客户端给服务器端发送一个**SYN报文**，并指明客户端的初始化序列号seq=x（SYN=1,ACK=0,seq=x）。此时客户端处于SYN_Send<同步已发送>状态。
   - SYN报文段不能携带数据，但需要消耗一个序号
2. 第二次握手：服务器收到客户端的SYN报文后，发送**SYN+ACK**报文，会以自己的SYN报文作为应答，同时也指定了自己的初始化序列号seq=y（SYN=1,ACK=1,seq=y,ack=x+1），同时会把客户端的序列号x+1作为确认号ack，表示自己已经收到了客户端的SYN，此时服务器处于SYN_REVD<同步收到>状态
3. 第三次握手：客户端收到SYN+ACK报文后，会发送一个**ACK报文**（ack=y+1），表示已经收到了服务器端的SYN报文，此时客户端处于established<已建立连接>状态（TCP连接成功）
   - ACK报文段可以携带数据，如果不携带数据则不消耗序号
4. 服务器端收到ACK报文后，也处于established状态，此时双方建立起了连接，客户端和服务器端可以正式开始传送数据

##### 为什么要三次握手？

防止失效的连接请求报文段被服务端接收而产生错误。<失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时上一个连接请求就是**失效的**>

若建立连接只进行两次握手，那客户端没有太大变化，仍需要获得服务器应答后才进入establish状态，而服务器段在收到连接请求后就进入establish状态。若此时网络拥塞，客户端发送的连接请求迟迟到不了服务器，客户端就会超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后会释放连接。此时如果那个失效的连接请求到达服务端，由于只有两次握手，服务端收到请求后进入establish状态，会等待发送数据或主动发送数据。但此时客户端早已进入closed状态，那么服务器端将会一直等下去，会浪费服务端的连接资源。

三次握手的主要目的：双方确认自己与对方的发送和接收都是正常的

- 第一次握手：client什么都不能确认；server确认对方发送正常、自己接收正常
- 第二次握手：client确认自己发送、接收正常，对方发送、接收正常；server确认自己接收正常，对方发送正常
- 第三次握手：client确认自己发送、接收正常，对方发送、接收正常；server确认自己发送、接收正常，对方发送、接收正常

所以三次握手能够确认双方都能正常发送、接收。

##### 为什么要传回SYN？

接收端传回发送端所发的SYN是为了告诉发送端，我收到的信息确实是你发送的信息

##### 为什么已经传了SYN还要传ACK

双发通信无误必须是两者互相发送的信息都无误。传SYN表示发送方到接收方的通道没问题，ACK用于验证接收方到发送方的通道

#### 四次挥手（终止连接）

1. 第一次挥手：客户端发送一个**FIN报文**，报文中会指定一个序列号（seq=u,FIN=1,u=前面已经传来的数据的最后一个字节的序号+1）。此时客户端处于FIN_WAIT1状态。
   - FIN报文段即使不携带数据，也要消耗一个序号
2. 第二次挥手：服务器端收到FIN报文后，会发送**ACK报文**，且把客户端的序列号+1作为ACK报文，表明已经收到客户端的报文了（seq=v,ACK=1,ack=u+1），此时服务器端处于CLOSE_WAIT状态。
   - TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时处于半关闭状态（客户端已经没有要发送的数据了，但服务器若发送数据，客户端仍要接收。整个状态需要持续一段时间，也就是整个CLOSE_WAIT持续的时间）
3. 客户端收到服务器的ACK报文后，就进入FIN_WAIT2状态，等待服务器端发送FIN报文（在这之前还需要接受服务器端发送的最后的数据）
4. 第三次挥手：如果服务器端将最后的数据发送完毕后，也想断开连接了，就和客户端的第一次挥手一样，发出**FIN报文**，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为w（FIN=1,seq=w,ack=u+1）。此时服务器端处于LAST_ACK状态等待客户端的确认。
5. 第四次挥手：客户端收到FIN报文后，同样发送一个**ACK报文**作为应答（ACK=1,seq=u+1,ack=w+1），此时客户端处于TIME_WAIT状态。【注】此时TCP连接还未释放，需要经过2xMSL（最长报文段寿命）的时间后，确保服务器端收到自己的ACK报文后才进入CLOSED状态。（seq=x,ack=y）
6. 服务器端收到ACK报文后，就立即关闭连接，处于CLOSED状态。（可以看出，服务器结束TCP连接的时间比客户端早一些）

ARQ协议的原理和过程

#### 线程间同步

锁机制：互斥锁、条件变量、信号量、读写锁

 互斥锁：提供了以排他方式数据结构被并发修改的方法

 读写锁：写锁优先抢占资源，读锁允许多个线程共同读共享数据，而写锁操作是互斥的

 条件变量：以原子方式阻塞进程，直到某个特定条件为真为止

 一般情况下：互斥锁起保护作用，条件变量和互斥锁一起使用

#### socket编程用到哪些函数，有什么作用

![img](https://pic4.zhimg.com/v2-752a91e57aea28d4b180c477c1d90bef_b.jpg)

#### https建立连接过程



#### 指针和引用的区别

指针：

引用：



- 
- 进程的状态
